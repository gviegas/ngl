const std = @import("std");
const testing = std.testing;

const ngl = @import("../ngl.zig");
const gpa = @import("test.zig").gpa;
const context = @import("test.zig").context;

test "draw command" {
    try testDrawCommand(false, @src().fn_name);
}

test "drawIndexed command" {
    try testDrawCommand(true, @src().fn_name);
}

fn testDrawCommand(comptime indexed: bool, comptime test_name: []const u8) !void {
    const ctx = context();
    const dev = &ctx.device;
    const queue_i = dev.findQueue(.{ .graphics = true }, null) orelse return error.SkipZigTest;

    var fence = try ngl.Fence.init(gpa, dev, .{});
    defer fence.deinit(gpa, dev);

    const clear_col = [4]f32{ 1, 1, 1, 1 };
    const vert_col = [4]f32{ 0, 0, 0, 1 };
    const clear_col_un: u32 = 0xff_ff_ff_ff;
    const vert_col_un = comptime std.mem.bigToNative(u32, 0x00_00_00_ff);

    const w = 64;
    const h = 36;

    const unif_data = [16]f32{
        1, 0,  0, 0,
        0, -1, 0, 0,
        0, 0,  1, 0,
        0, 0,  0, 1,
    };
    const unif_size = blk: {
        const sz = @sizeOf(@TypeOf(unif_data));
        break :blk (sz + 255) & ~@as(u64, 255);
    };

    const vert_data = [3]packed struct {
        x: f32,
        y: f32,
        z: f32,
        r: f32 = vert_col[0],
        g: f32 = vert_col[1],
        b: f32 = vert_col[2],
        a: f32 = vert_col[3],
    }{
        .{ .x = -1, .y = -1, .z = 0.5 },
        .{ .x = 1, .y = -1, .z = 0.5 },
        .{ .x = 0, .y = 1, .z = 0.5 },
    };
    const vert_size = blk: {
        const sz = @sizeOf(@TypeOf(vert_data));
        break :blk (sz + 255) & ~@as(u64, 255);
    };

    // Invert the winding order for indexed draw.
    const idx_data = if (indexed) [3]u16{ 2, 1, 0 } else {};
    const idx_size = @sizeOf(@TypeOf(idx_data));

    const size = @max(w * h * 4, unif_size + vert_size + idx_size);

    var image = try ngl.Image.init(gpa, dev, .{
        .type = .@"2d",
        .format = .rgba8_unorm,
        .width = w,
        .height = h,
        .depth_or_layers = 1,
        .levels = 1,
        .samples = .@"1",
        .tiling = .optimal,
        .usage = .{ .color_attachment = true, .transfer_source = true },
        .misc = .{},
    });
    var img_mem = blk: {
        errdefer image.deinit(gpa, dev);
        const mem_reqs = image.getMemoryRequirements(dev);
        var mem = try dev.alloc(gpa, .{
            .size = mem_reqs.size,
            .type_index = mem_reqs.findType(dev.*, .{ .device_local = true }, null).?,
        });
        errdefer dev.free(gpa, &mem);
        try image.bind(dev, &mem, 0);
        break :blk mem;
    };
    defer {
        image.deinit(gpa, dev);
        dev.free(gpa, &img_mem);
    }
    var img_view = try ngl.ImageView.init(gpa, dev, .{
        .image = &image,
        .type = .@"2d",
        .format = .rgba8_unorm,
        .range = .{
            .aspect_mask = .{ .color = true },
            .level = 0,
            .levels = 1,
            .layer = 0,
            .layers = 1,
        },
    });
    defer img_view.deinit(gpa, dev);

    var unif_buf = try ngl.Buffer.init(gpa, dev, .{
        .size = unif_size,
        .usage = .{ .uniform_buffer = true, .transfer_dest = true },
    });
    var unif_buf_mem = blk: {
        errdefer unif_buf.deinit(gpa, dev);
        const mem_reqs = unif_buf.getMemoryRequirements(dev);
        var mem = try dev.alloc(gpa, .{
            .size = mem_reqs.size,
            .type_index = mem_reqs.findType(dev.*, .{ .device_local = true }, null).?,
        });
        errdefer dev.free(gpa, &mem);
        try unif_buf.bind(dev, &mem, 0);
        break :blk mem;
    };
    defer {
        unif_buf.deinit(gpa, dev);
        dev.free(gpa, &unif_buf_mem);
    }

    var vert_buf = try ngl.Buffer.init(gpa, dev, .{
        .size = vert_size,
        .usage = .{ .vertex_buffer = true, .transfer_dest = true },
    });
    var vert_buf_mem = blk: {
        errdefer vert_buf.deinit(gpa, dev);
        const mem_reqs = vert_buf.getMemoryRequirements(dev);
        var mem = try dev.alloc(gpa, .{
            .size = mem_reqs.size,
            .type_index = mem_reqs.findType(dev.*, .{ .device_local = true }, null).?,
        });
        errdefer dev.free(gpa, &mem);
        try vert_buf.bind(dev, &mem, 0);
        break :blk mem;
    };
    defer {
        vert_buf.deinit(gpa, dev);
        dev.free(gpa, &vert_buf_mem);
    }

    var idx_buf: ngl.Buffer = undefined;
    var idx_buf_mem: ngl.Memory = undefined;
    if (indexed) {
        idx_buf = try ngl.Buffer.init(gpa, dev, .{
            .size = idx_size,
            .usage = .{ .index_buffer = true, .transfer_dest = true },
        });
        idx_buf_mem = blk: {
            errdefer idx_buf.deinit(gpa, dev);
            const mem_reqs = idx_buf.getMemoryRequirements(dev);
            var mem = try dev.alloc(gpa, .{
                .size = mem_reqs.size,
                .type_index = mem_reqs.findType(dev.*, .{ .device_local = true }, null).?,
            });
            errdefer dev.free(gpa, &mem);
            try idx_buf.bind(dev, &mem, 0);
            break :blk mem;
        };
    }
    defer if (indexed) {
        idx_buf.deinit(gpa, dev);
        dev.free(gpa, &idx_buf_mem);
    };

    var stg_buf = try ngl.Buffer.init(gpa, dev, .{
        .size = size,
        .usage = .{ .transfer_source = true, .transfer_dest = true },
    });
    var stg_buf_mem = blk: {
        errdefer stg_buf.deinit(gpa, dev);
        const mem_reqs = stg_buf.getMemoryRequirements(dev);
        var mem = try dev.alloc(gpa, .{
            .size = mem_reqs.size,
            .type_index = mem_reqs.findType(dev.*, .{
                .host_visible = true,
                .host_coherent = true,
            }, null).?,
        });
        errdefer dev.free(gpa, &mem);
        try stg_buf.bind(dev, &mem, 0);
        break :blk mem;
    };
    defer {
        stg_buf.deinit(gpa, dev);
        dev.free(gpa, &stg_buf_mem);
    }

    var set_layt = try ngl.DescriptorSetLayout.init(gpa, dev, .{
        .bindings = &.{.{
            .binding = 0,
            .type = .uniform_buffer,
            .count = 1,
            .shader_mask = .{ .vertex = true },
            .immutable_samplers = &.{},
        }},
    });
    defer set_layt.deinit(gpa, dev);

    var shd_layt = try ngl.ShaderLayout.init(gpa, dev, .{
        .set_layouts = &.{&set_layt},
        .push_constants = &.{},
    });
    defer shd_layt.deinit(gpa, dev);

    const shaders = try ngl.Shader.init(gpa, dev, &.{
        .{
            .type = .vertex,
            .next = .{ .fragment = true },
            .code = &vert_spv,
            .name = "main",
            .set_layouts = &.{&set_layt},
            .push_constants = &.{},
            .specialization = null,
            .link = true,
        },
        .{
            .type = .fragment,
            .next = .{},
            .code = &frag_spv,
            .name = "main",
            .set_layouts = &.{&set_layt},
            .push_constants = &.{},
            .specialization = null,
            .link = true,
        },
    });
    defer {
        for (shaders) |*shd|
            if (shd.*) |*s| s.deinit(gpa, dev) else |_| {};
        gpa.free(shaders);
    }

    var desc_pool = try ngl.DescriptorPool.init(gpa, dev, .{
        .max_sets = 1,
        .pool_size = .{ .uniform_buffer = 1 },
    });
    defer desc_pool.deinit(gpa, dev);
    var desc_set = blk: {
        const s = try desc_pool.alloc(gpa, dev, .{ .layouts = &.{&set_layt} });
        defer gpa.free(s);
        break :blk s[0];
    };

    try ngl.DescriptorSet.write(gpa, dev, &.{.{
        .descriptor_set = &desc_set,
        .binding = 0,
        .element = 0,
        .contents = .{ .uniform_buffer = &.{.{
            .buffer = &unif_buf,
            .offset = 0,
            .range = unif_size,
        }} },
    }});

    // Keep mapped.
    var p = try stg_buf_mem.map(dev, 0, null);
    {
        const len = @sizeOf(@TypeOf(unif_data));
        const source = @as([*]const u8, @ptrCast(&unif_data))[0..len];
        const dest = p[0..len];
        @memcpy(dest, source);
    }
    {
        const len = @sizeOf(@TypeOf(vert_data));
        const source = @as([*]const u8, @ptrCast(&vert_data))[0..len];
        const dest = p[unif_size .. unif_size + len];
        @memcpy(dest, source);
    }
    if (indexed) {
        const len = @sizeOf(@TypeOf(idx_data));
        const source = @as([*]const u8, @ptrCast(&idx_data))[0..len];
        const dest = p[size - len .. size];
        @memcpy(dest, source);
    }

    var cmd_pool = try ngl.CommandPool.init(gpa, dev, .{ .queue = &dev.queues[queue_i] });
    defer cmd_pool.deinit(gpa, dev);
    var cmd_buf = blk: {
        const s = try cmd_pool.alloc(gpa, dev, .{ .level = .primary, .count = 1 });
        defer gpa.free(s);
        break :blk s[0];
    };

    // Update uniform/vertex/index buffers using a staging buffer,
    // then record a render pass instance that draws to a single
    // color attachment, then copy this attachment back to the
    // staging buffer.

    var cmd = try cmd_buf.begin(gpa, dev, .{ .one_time_submit = true, .inheritance = null });

    cmd.copyBuffer(&[_]ngl.Cmd.BufferCopy{
        .{
            .source = &stg_buf,
            .dest = &unif_buf,
            .regions = &.{.{
                .source_offset = 0,
                .dest_offset = 0,
                .size = unif_size, // Note `unif_size`.
            }},
        },
        .{
            .source = &stg_buf,
            .dest = &vert_buf,
            .regions = &.{.{
                .source_offset = unif_size,
                .dest_offset = 0,
                .size = vert_size, // Note `vert_size`.
            }},
        },
    } ++ if (indexed) &[_]ngl.Cmd.BufferCopy{.{
        .source = &stg_buf,
        .dest = &idx_buf,
        .regions = &.{.{
            .source_offset = size - idx_size,
            .dest_offset = 0,
            .size = idx_size, // This one matches the data size.
        }},
    }} else &[_]ngl.Cmd.BufferCopy{});

    cmd.barrier(&.{.{
        .global = &.{.{
            .source_stage_mask = .{ .copy = true },
            .source_access_mask = .{ .transfer_write = true },
            .dest_stage_mask = .{
                .index_input = true,
                .vertex_attribute_input = true,
                .vertex_shader = true,
            },
            .dest_access_mask = .{
                .index_read = true,
                .vertex_attribute_read = true,
                .uniform_read = true,
            },
        }},
        .image = &.{.{
            .source_stage_mask = .{},
            .source_access_mask = .{},
            .dest_stage_mask = .{ .color_attachment_output = true },
            .dest_access_mask = .{ .color_attachment_write = true },
            .queue_transfer = null,
            .old_layout = .unknown,
            .new_layout = .color_attachment_optimal,
            .image = &image,
            .range = .{
                .aspect_mask = .{ .color = true },
                .level = 0,
                .levels = 1,
                .layer = 0,
                .layers = 1,
            },
        }},
    }});

    cmd.beginRendering(.{
        .colors = &.{.{
            .view = &img_view,
            .layout = .color_attachment_optimal,
            .load_op = .clear,
            .store_op = .store,
            .clear_value = .{ .color_f32 = clear_col },
            .resolve = null,
        }},
        .depth = null,
        .stencil = null,
        .render_area = .{ .width = w, .height = h },
        .layers = 1,
        .contents = .@"inline",
    });

    cmd.setShaders(
        &.{
            .fragment,
            .vertex,
        },
        &.{
            if (shaders[1]) |*shd| shd else |err| return err,
            if (shaders[0]) |*shd| shd else |err| return err,
        },
    );

    cmd.setVertexInput(
        &.{.{
            .binding = 0,
            .stride = @sizeOf(@TypeOf(vert_data[0])),
            .step_rate = .vertex,
        }},
        &.{
            .{
                .location = 1,
                .binding = 0,
                .format = .rgba32_sfloat,
                .offset = 3 * 4,
            },
            .{
                .location = 0,
                .binding = 0,
                .format = .rgb32_sfloat,
                .offset = 0,
            },
        },
    );
    cmd.setPrimitiveTopology(.triangle_list);

    cmd.setViewports(&.{.{
        .x = 0,
        .y = 0,
        .width = w,
        .height = h,
        .znear = 0,
        .zfar = 1,
    }});
    cmd.setScissorRects(&.{.{
        .x = 0,
        .y = 0,
        .width = w,
        .height = h,
    }});

    cmd.setRasterizationEnable(true);
    cmd.setPolygonMode(.fill);
    cmd.setCullMode(.front); // Due to the uniform's transform.
    cmd.setFrontFace(if (indexed) .counter_clockwise else .clockwise);
    cmd.setSampleCount(.@"1");
    cmd.setSampleMask(0b1);
    cmd.setDepthBiasEnable(false);
    cmd.setDepthTestEnable(false);
    cmd.setDepthWriteEnable(false);
    cmd.setStencilTestEnable(false);
    cmd.setColorBlendEnable(0, &.{false});
    cmd.setColorWrite(0, &.{.all});

    cmd.setDescriptors(.graphics, &shd_layt, 0, &.{&desc_set});

    cmd.setVertexBuffers(0, &.{&vert_buf}, &.{0}, &.{vert_size}); // Note `vert_size`.

    if (!indexed) {
        cmd.draw(3, 1, 0, 0);
    } else {
        cmd.setIndexBuffer(.u16, &idx_buf, 0, idx_size);
        cmd.drawIndexed(3, 1, 0, 0, 0);
    }

    cmd.endRendering();

    cmd.barrier(&.{.{
        .image = &.{.{
            .source_stage_mask = .{ .color_attachment_output = true },
            .source_access_mask = .{ .color_attachment_write = true },
            .dest_stage_mask = .{ .copy = true },
            .dest_access_mask = .{ .transfer_read = true, .transfer_write = true },
            .queue_transfer = null,
            .old_layout = .color_attachment_optimal,
            .new_layout = .transfer_source_optimal,
            .image = &image,
            .range = .{
                .aspect_mask = .{ .color = true },
                .level = 0,
                .levels = 1,
                .layer = 0,
                .layers = 1,
            },
        }},
    }});

    cmd.copyImageToBuffer(&.{.{
        .buffer = &stg_buf,
        .image = &image,
        .image_layout = .transfer_source_optimal,
        .regions = &.{.{
            .buffer_offset = 0,
            .buffer_row_length = w,
            .buffer_image_height = h,
            .image_aspect = .color,
            .image_level = 0,
            .image_x = 0,
            .image_y = 0,
            .image_z_or_layer = 0,
            .image_width = w,
            .image_height = h,
            .image_depth_or_layers = 1,
        }},
    }});

    try cmd.end();

    {
        ctx.lockQueue(queue_i);
        defer ctx.unlockQueue(queue_i);

        try dev.queues[queue_i].submit(gpa, dev, &fence, &.{.{
            .commands = &.{.{ .command_buffer = &cmd_buf }},
            .wait = &.{},
            .signal = &.{},
        }});
    }

    try ngl.Fence.wait(gpa, dev, std.time.ns_per_s, &.{&fence});

    // What the render pass did:
    // 1. Cleared the color attachment to `clear_col` values.
    // 2. Drew an inverted triangle in clip coordinates (assuming a
    //    top-left origin) using `vert_col` as vertex color and
    //    with a transform that flips the vertex positions.

    const s = @as([*]const u32, @ptrCast(@alignCast(p)))[0 .. w * h];

    const clear_col_n = std.mem.count(u32, s, &.{clear_col_un});
    const vert_col_n = std.mem.count(u32, s, &.{vert_col_un});

    try testing.expect(clear_col_n != 0);
    try testing.expect(vert_col_n != 0);
    try testing.expectEqual(clear_col_n + vert_col_n, w * h);

    // The uniform's transform must have flipped the triangle
    // such that it's no longer inverted.
    const tip_beg = std.mem.indexOfScalar(u32, s, vert_col_un).?;
    const tip_len = std.mem.indexOfScalar(u32, s[tip_beg..], clear_col_un).?;
    const base_end = std.mem.lastIndexOfScalar(u32, s, vert_col_un).?;
    const base_len = base_end - std.mem.lastIndexOfScalar(u32, s[0..base_end], clear_col_un).?;
    try testing.expect(tip_len < base_len);
    var prev_len = tip_len;
    for (1 + tip_beg / w..1 + base_end / w) |i| {
        const len = std.mem.count(u32, s[i * w .. i * w + w], &.{vert_col_un});
        try testing.expect(len >= prev_len);
        prev_len = len;
    }

    // TODO: May need to relax this (even more).
    try testing.expectApproxEqAbs(
        @as(f64, @floatFromInt(clear_col_n)) / @as(f64, @floatFromInt(vert_col_n)),
        1,
        if (w & 1 == 0 and h & 1 == 0) 0 else 0.1,
    );

    if (indexed) return;

    if (@import("test.zig").writer) |writer| {
        var str = std.ArrayList(u8).init(gpa);
        defer str.deinit();
        try str.appendSlice("\n" ++ test_name ++ "\n");
        for (0..h) |y| {
            for (0..w) |x| {
                const i = (x + w * y) * 4;
                const data = @as([*]const u32, @ptrCast(@alignCast(p + i)))[0];
                try str.appendSlice(switch (data) {
                    clear_col_un => "⚫",
                    vert_col_un => "🐩",
                    else => unreachable,
                });
            }
            try str.append('\n');
        }
        try writer.print("{s}", .{str.items});
    }
}

// #version 460 core
//
// layout(set = 0, binding = 0) uniform UniformBuffer {
//     mat4 m;
// } uniform_buffer;
//
// layout(location = 0) in vec3 position;
// layout(location = 1) in vec4 color;
//
// layout(location = 0) out Vertex {
//     vec4 color;
// } vertex;
//
// void main() {
//     const vec4 pos = uniform_buffer.m * vec4(position, 1.0);
//     vertex.color = color;
//     gl_Position = pos;
// }
const vert_spv align(4) = [1104]u8{
    0x3,  0x2, 0x23, 0x7, 0x0,  0x0,  0x1,  0x0,  0xb,  0x0,  0x8,  0x0,  0x2d, 0x0,  0x0,  0x0,
    0x0,  0x0, 0x0,  0x0, 0x11, 0x0,  0x2,  0x0,  0x1,  0x0,  0x0,  0x0,  0xb,  0x0,  0x6,  0x0,
    0x1,  0x0, 0x0,  0x0, 0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30,
    0x0,  0x0, 0x0,  0x0, 0xe,  0x0,  0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,
    0xf,  0x0, 0x9,  0x0, 0x0,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0x6d, 0x61, 0x69, 0x6e,
    0x0,  0x0, 0x0,  0x0, 0x15, 0x0,  0x0,  0x0,  0x1f, 0x0,  0x0,  0x0,  0x21, 0x0,  0x0,  0x0,
    0x2a, 0x0, 0x0,  0x0, 0x48, 0x0,  0x4,  0x0,  0xb,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x5,  0x0, 0x0,  0x0, 0x48, 0x0,  0x5,  0x0,  0xb,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x23, 0x0, 0x0,  0x0, 0x0,  0x0,  0x0,  0x0,  0x48, 0x0,  0x5,  0x0,  0xb,  0x0,  0x0,  0x0,
    0x0,  0x0, 0x0,  0x0, 0x7,  0x0,  0x0,  0x0,  0x10, 0x0,  0x0,  0x0,  0x47, 0x0,  0x3,  0x0,
    0xb,  0x0, 0x0,  0x0, 0x2,  0x0,  0x0,  0x0,  0x47, 0x0,  0x4,  0x0,  0xd,  0x0,  0x0,  0x0,
    0x22, 0x0, 0x0,  0x0, 0x0,  0x0,  0x0,  0x0,  0x47, 0x0,  0x4,  0x0,  0xd,  0x0,  0x0,  0x0,
    0x21, 0x0, 0x0,  0x0, 0x0,  0x0,  0x0,  0x0,  0x47, 0x0,  0x4,  0x0,  0x15, 0x0,  0x0,  0x0,
    0x1e, 0x0, 0x0,  0x0, 0x0,  0x0,  0x0,  0x0,  0x47, 0x0,  0x3,  0x0,  0x1d, 0x0,  0x0,  0x0,
    0x2,  0x0, 0x0,  0x0, 0x47, 0x0,  0x4,  0x0,  0x1f, 0x0,  0x0,  0x0,  0x1e, 0x0,  0x0,  0x0,
    0x0,  0x0, 0x0,  0x0, 0x47, 0x0,  0x4,  0x0,  0x21, 0x0,  0x0,  0x0,  0x1e, 0x0,  0x0,  0x0,
    0x1,  0x0, 0x0,  0x0, 0x48, 0x0,  0x5,  0x0,  0x28, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0xb,  0x0, 0x0,  0x0, 0x0,  0x0,  0x0,  0x0,  0x48, 0x0,  0x5,  0x0,  0x28, 0x0,  0x0,  0x0,
    0x1,  0x0, 0x0,  0x0, 0xb,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x48, 0x0,  0x5,  0x0,
    0x28, 0x0, 0x0,  0x0, 0x2,  0x0,  0x0,  0x0,  0xb,  0x0,  0x0,  0x0,  0x3,  0x0,  0x0,  0x0,
    0x48, 0x0, 0x5,  0x0, 0x28, 0x0,  0x0,  0x0,  0x3,  0x0,  0x0,  0x0,  0xb,  0x0,  0x0,  0x0,
    0x4,  0x0, 0x0,  0x0, 0x47, 0x0,  0x3,  0x0,  0x28, 0x0,  0x0,  0x0,  0x2,  0x0,  0x0,  0x0,
    0x13, 0x0, 0x2,  0x0, 0x2,  0x0,  0x0,  0x0,  0x21, 0x0,  0x3,  0x0,  0x3,  0x0,  0x0,  0x0,
    0x2,  0x0, 0x0,  0x0, 0x16, 0x0,  0x3,  0x0,  0x6,  0x0,  0x0,  0x0,  0x20, 0x0,  0x0,  0x0,
    0x17, 0x0, 0x4,  0x0, 0x7,  0x0,  0x0,  0x0,  0x6,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,
    0x20, 0x0, 0x4,  0x0, 0x8,  0x0,  0x0,  0x0,  0x7,  0x0,  0x0,  0x0,  0x7,  0x0,  0x0,  0x0,
    0x18, 0x0, 0x4,  0x0, 0xa,  0x0,  0x0,  0x0,  0x7,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,
    0x1e, 0x0, 0x3,  0x0, 0xb,  0x0,  0x0,  0x0,  0xa,  0x0,  0x0,  0x0,  0x20, 0x0,  0x4,  0x0,
    0xc,  0x0, 0x0,  0x0, 0x2,  0x0,  0x0,  0x0,  0xb,  0x0,  0x0,  0x0,  0x3b, 0x0,  0x4,  0x0,
    0xc,  0x0, 0x0,  0x0, 0xd,  0x0,  0x0,  0x0,  0x2,  0x0,  0x0,  0x0,  0x15, 0x0,  0x4,  0x0,
    0xe,  0x0, 0x0,  0x0, 0x20, 0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x2b, 0x0,  0x4,  0x0,
    0xe,  0x0, 0x0,  0x0, 0xf,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20, 0x0,  0x4,  0x0,
    0x10, 0x0, 0x0,  0x0, 0x2,  0x0,  0x0,  0x0,  0xa,  0x0,  0x0,  0x0,  0x17, 0x0,  0x4,  0x0,
    0x13, 0x0, 0x0,  0x0, 0x6,  0x0,  0x0,  0x0,  0x3,  0x0,  0x0,  0x0,  0x20, 0x0,  0x4,  0x0,
    0x14, 0x0, 0x0,  0x0, 0x1,  0x0,  0x0,  0x0,  0x13, 0x0,  0x0,  0x0,  0x3b, 0x0,  0x4,  0x0,
    0x14, 0x0, 0x0,  0x0, 0x15, 0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x2b, 0x0,  0x4,  0x0,
    0x6,  0x0, 0x0,  0x0, 0x17, 0x0,  0x0,  0x0,  0x0,  0x0,  0x80, 0x3f, 0x1e, 0x0,  0x3,  0x0,
    0x1d, 0x0, 0x0,  0x0, 0x7,  0x0,  0x0,  0x0,  0x20, 0x0,  0x4,  0x0,  0x1e, 0x0,  0x0,  0x0,
    0x3,  0x0, 0x0,  0x0, 0x1d, 0x0,  0x0,  0x0,  0x3b, 0x0,  0x4,  0x0,  0x1e, 0x0,  0x0,  0x0,
    0x1f, 0x0, 0x0,  0x0, 0x3,  0x0,  0x0,  0x0,  0x20, 0x0,  0x4,  0x0,  0x20, 0x0,  0x0,  0x0,
    0x1,  0x0, 0x0,  0x0, 0x7,  0x0,  0x0,  0x0,  0x3b, 0x0,  0x4,  0x0,  0x20, 0x0,  0x0,  0x0,
    0x21, 0x0, 0x0,  0x0, 0x1,  0x0,  0x0,  0x0,  0x20, 0x0,  0x4,  0x0,  0x23, 0x0,  0x0,  0x0,
    0x3,  0x0, 0x0,  0x0, 0x7,  0x0,  0x0,  0x0,  0x15, 0x0,  0x4,  0x0,  0x25, 0x0,  0x0,  0x0,
    0x20, 0x0, 0x0,  0x0, 0x0,  0x0,  0x0,  0x0,  0x2b, 0x0,  0x4,  0x0,  0x25, 0x0,  0x0,  0x0,
    0x26, 0x0, 0x0,  0x0, 0x1,  0x0,  0x0,  0x0,  0x1c, 0x0,  0x4,  0x0,  0x27, 0x0,  0x0,  0x0,
    0x6,  0x0, 0x0,  0x0, 0x26, 0x0,  0x0,  0x0,  0x1e, 0x0,  0x6,  0x0,  0x28, 0x0,  0x0,  0x0,
    0x7,  0x0, 0x0,  0x0, 0x6,  0x0,  0x0,  0x0,  0x27, 0x0,  0x0,  0x0,  0x27, 0x0,  0x0,  0x0,
    0x20, 0x0, 0x4,  0x0, 0x29, 0x0,  0x0,  0x0,  0x3,  0x0,  0x0,  0x0,  0x28, 0x0,  0x0,  0x0,
    0x3b, 0x0, 0x4,  0x0, 0x29, 0x0,  0x0,  0x0,  0x2a, 0x0,  0x0,  0x0,  0x3,  0x0,  0x0,  0x0,
    0x36, 0x0, 0x5,  0x0, 0x2,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x3,  0x0, 0x0,  0x0, 0xf8, 0x0,  0x2,  0x0,  0x5,  0x0,  0x0,  0x0,  0x3b, 0x0,  0x4,  0x0,
    0x8,  0x0, 0x0,  0x0, 0x9,  0x0,  0x0,  0x0,  0x7,  0x0,  0x0,  0x0,  0x41, 0x0,  0x5,  0x0,
    0x10, 0x0, 0x0,  0x0, 0x11, 0x0,  0x0,  0x0,  0xd,  0x0,  0x0,  0x0,  0xf,  0x0,  0x0,  0x0,
    0x3d, 0x0, 0x4,  0x0, 0xa,  0x0,  0x0,  0x0,  0x12, 0x0,  0x0,  0x0,  0x11, 0x0,  0x0,  0x0,
    0x3d, 0x0, 0x4,  0x0, 0x13, 0x0,  0x0,  0x0,  0x16, 0x0,  0x0,  0x0,  0x15, 0x0,  0x0,  0x0,
    0x51, 0x0, 0x5,  0x0, 0x6,  0x0,  0x0,  0x0,  0x18, 0x0,  0x0,  0x0,  0x16, 0x0,  0x0,  0x0,
    0x0,  0x0, 0x0,  0x0, 0x51, 0x0,  0x5,  0x0,  0x6,  0x0,  0x0,  0x0,  0x19, 0x0,  0x0,  0x0,
    0x16, 0x0, 0x0,  0x0, 0x1,  0x0,  0x0,  0x0,  0x51, 0x0,  0x5,  0x0,  0x6,  0x0,  0x0,  0x0,
    0x1a, 0x0, 0x0,  0x0, 0x16, 0x0,  0x0,  0x0,  0x2,  0x0,  0x0,  0x0,  0x50, 0x0,  0x7,  0x0,
    0x7,  0x0, 0x0,  0x0, 0x1b, 0x0,  0x0,  0x0,  0x18, 0x0,  0x0,  0x0,  0x19, 0x0,  0x0,  0x0,
    0x1a, 0x0, 0x0,  0x0, 0x17, 0x0,  0x0,  0x0,  0x91, 0x0,  0x5,  0x0,  0x7,  0x0,  0x0,  0x0,
    0x1c, 0x0, 0x0,  0x0, 0x12, 0x0,  0x0,  0x0,  0x1b, 0x0,  0x0,  0x0,  0x3e, 0x0,  0x3,  0x0,
    0x9,  0x0, 0x0,  0x0, 0x1c, 0x0,  0x0,  0x0,  0x3d, 0x0,  0x4,  0x0,  0x7,  0x0,  0x0,  0x0,
    0x22, 0x0, 0x0,  0x0, 0x21, 0x0,  0x0,  0x0,  0x41, 0x0,  0x5,  0x0,  0x23, 0x0,  0x0,  0x0,
    0x24, 0x0, 0x0,  0x0, 0x1f, 0x0,  0x0,  0x0,  0xf,  0x0,  0x0,  0x0,  0x3e, 0x0,  0x3,  0x0,
    0x24, 0x0, 0x0,  0x0, 0x22, 0x0,  0x0,  0x0,  0x3d, 0x0,  0x4,  0x0,  0x7,  0x0,  0x0,  0x0,
    0x2b, 0x0, 0x0,  0x0, 0x9,  0x0,  0x0,  0x0,  0x41, 0x0,  0x5,  0x0,  0x23, 0x0,  0x0,  0x0,
    0x2c, 0x0, 0x0,  0x0, 0x2a, 0x0,  0x0,  0x0,  0xf,  0x0,  0x0,  0x0,  0x3e, 0x0,  0x3,  0x0,
    0x2c, 0x0, 0x0,  0x0, 0x2b, 0x0,  0x0,  0x0,  0xfd, 0x0,  0x1,  0x0,  0x38, 0x0,  0x1,  0x0,
};

// #version 460 core
//
// layout(location = 0) in Vertex {
//     vec4 color;
// } vertex;
//
// layout(location = 0) out vec4 color_0;
//
// void main() {
//     color_0 = vertex.color;
// }
const frag_spv align(4) = [404]u8{
    0x3,  0x2, 0x23, 0x7, 0x0,  0x0,  0x1,  0x0,  0xb,  0x0,  0x8,  0x0,  0x12, 0x0,  0x0,  0x0,
    0x0,  0x0, 0x0,  0x0, 0x11, 0x0,  0x2,  0x0,  0x1,  0x0,  0x0,  0x0,  0xb,  0x0,  0x6,  0x0,
    0x1,  0x0, 0x0,  0x0, 0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30,
    0x0,  0x0, 0x0,  0x0, 0xe,  0x0,  0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,
    0xf,  0x0, 0x7,  0x0, 0x4,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0x6d, 0x61, 0x69, 0x6e,
    0x0,  0x0, 0x0,  0x0, 0x9,  0x0,  0x0,  0x0,  0xc,  0x0,  0x0,  0x0,  0x10, 0x0,  0x3,  0x0,
    0x4,  0x0, 0x0,  0x0, 0x7,  0x0,  0x0,  0x0,  0x47, 0x0,  0x4,  0x0,  0x9,  0x0,  0x0,  0x0,
    0x1e, 0x0, 0x0,  0x0, 0x0,  0x0,  0x0,  0x0,  0x47, 0x0,  0x3,  0x0,  0xa,  0x0,  0x0,  0x0,
    0x2,  0x0, 0x0,  0x0, 0x47, 0x0,  0x4,  0x0,  0xc,  0x0,  0x0,  0x0,  0x1e, 0x0,  0x0,  0x0,
    0x0,  0x0, 0x0,  0x0, 0x13, 0x0,  0x2,  0x0,  0x2,  0x0,  0x0,  0x0,  0x21, 0x0,  0x3,  0x0,
    0x3,  0x0, 0x0,  0x0, 0x2,  0x0,  0x0,  0x0,  0x16, 0x0,  0x3,  0x0,  0x6,  0x0,  0x0,  0x0,
    0x20, 0x0, 0x0,  0x0, 0x17, 0x0,  0x4,  0x0,  0x7,  0x0,  0x0,  0x0,  0x6,  0x0,  0x0,  0x0,
    0x4,  0x0, 0x0,  0x0, 0x20, 0x0,  0x4,  0x0,  0x8,  0x0,  0x0,  0x0,  0x3,  0x0,  0x0,  0x0,
    0x7,  0x0, 0x0,  0x0, 0x3b, 0x0,  0x4,  0x0,  0x8,  0x0,  0x0,  0x0,  0x9,  0x0,  0x0,  0x0,
    0x3,  0x0, 0x0,  0x0, 0x1e, 0x0,  0x3,  0x0,  0xa,  0x0,  0x0,  0x0,  0x7,  0x0,  0x0,  0x0,
    0x20, 0x0, 0x4,  0x0, 0xb,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0xa,  0x0,  0x0,  0x0,
    0x3b, 0x0, 0x4,  0x0, 0xb,  0x0,  0x0,  0x0,  0xc,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,
    0x15, 0x0, 0x4,  0x0, 0xd,  0x0,  0x0,  0x0,  0x20, 0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,
    0x2b, 0x0, 0x4,  0x0, 0xd,  0x0,  0x0,  0x0,  0xe,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x20, 0x0, 0x4,  0x0, 0xf,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x7,  0x0,  0x0,  0x0,
    0x36, 0x0, 0x5,  0x0, 0x2,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x3,  0x0, 0x0,  0x0, 0xf8, 0x0,  0x2,  0x0,  0x5,  0x0,  0x0,  0x0,  0x41, 0x0,  0x5,  0x0,
    0xf,  0x0, 0x0,  0x0, 0x10, 0x0,  0x0,  0x0,  0xc,  0x0,  0x0,  0x0,  0xe,  0x0,  0x0,  0x0,
    0x3d, 0x0, 0x4,  0x0, 0x7,  0x0,  0x0,  0x0,  0x11, 0x0,  0x0,  0x0,  0x10, 0x0,  0x0,  0x0,
    0x3e, 0x0, 0x3,  0x0, 0x9,  0x0,  0x0,  0x0,  0x11, 0x0,  0x0,  0x0,  0xfd, 0x0,  0x1,  0x0,
    0x38, 0x0, 0x1,  0x0,
};
